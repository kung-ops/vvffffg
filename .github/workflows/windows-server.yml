name: Windows Server Continuous Integration
on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - development
        - staging
        - production
      verbose:
        description: 'Enable verbose logging'
        required: false
        default: false

env:
  BUILD_CONFIGURATION: 'Release'
  DOTNET_VERSION: '6.0.x'
  NODE_VERSION: '18.x'

jobs:
  build-and-test:
    name: Build and Test
    runs-on: windows-latest
    
    strategy:
      matrix:
        dotnet-version: ['6.0.x', '7.0.x']
        
    timeout-minutes: 120
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        lfs: true
        
    - name: Display Windows Server Information
      run: |
        Write-Host "=== WINDOWS SERVER ENVIRONMENT ==="
        Write-Host "GitHub Runner: ${{ runner.os }}"
        Write-Host "Runner Name: ${{ runner.name }}"
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Event: ${{ github.event_name }}"
        Write-Host "Ref: ${{ github.ref }}"
        Write-Host "SHA: ${{ github.sha }}"
        
        Write-Host "`n=== SYSTEM INFORMATION ==="
        systeminfo | Select-String "OS Name", "OS Version", "System Type", "Total Physical Memory"
        
        Write-Host "`n=== DISK INFORMATION ==="
        Get-PSDrive C | Format-List Name, @{n='Free(GB)';e={[math]::Round($_.Free/1GB,2)}}, @{n='Used(GB)';e={[math]::Round($_.Used/1GB,2)}}, @{n='Total(GB)';e={[math]::Round(($_.Free+$_.Used)/1GB,2)}}
        
        Write-Host "`n=== ENVIRONMENT VARIABLES ==="
        Get-ChildItem Env: | Sort-Object Name | Select-Object -First 10
        
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install Chocolatey Packages
      if: matrix.dotnet-version == '6.0.x'
      run: |
        Write-Host "Installing development tools via Chocolatey..."
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        
        # Install Chocolatey if not present
        if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
            Write-Host "Installing Chocolatey..."
            iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
        }
        
        # Install common development tools
        choco install -y git.install --params "/GitAndUnixToolsOnPath"
        choco install -y 7zip
        choco install -y sysinternals
        choco install -y curl
        choco install -y wget
        
        # Display installed packages
        choco list --local-only
        
    - name: Restore Dependencies
      run: |
        Write-Host "Restoring dependencies..."
        
        # Check for project files and restore accordingly
        $projects = @(
          (Get-ChildItem -Path . -Recurse -Filter "*.sln" | Select-Object -First 1),
          (Get-ChildItem -Path . -Recurse -Filter "*.csproj" | Select-Object -First 1),
          (Get-ChildItem -Path . -Recurse -Filter "package.json" | Select-Object -First 1)
        )
        
        foreach ($project in $projects) {
          if ($project) {
            Write-Host "Found project file: $($project.FullName)"
            if ($project.Extension -eq ".sln" -or $project.Extension -eq ".csproj") {
              dotnet restore $project.FullName --verbosity minimal
            }
            elseif ($project.Name -eq "package.json") {
              npm ci
            }
          }
        }
        
        if (-not $projects[0]) {
          Write-Host "No project files found. Creating sample project..."
          dotnet new console -n SampleApp --force
          cd SampleApp
          dotnet restore
        }
        
    - name: Build Solution
      run: |
        Write-Host "Building solution with configuration: ${{ env.BUILD_CONFIGURATION }}"
        
        $slnFiles = Get-ChildItem -Path . -Recurse -Filter "*.sln"
        $csprojFiles = Get-ChildItem -Path . -Recurse -Filter "*.csproj"
        
        if ($slnFiles.Count -gt 0) {
          foreach ($sln in $slnFiles) {
            Write-Host "Building solution: $($sln.Name)"
            dotnet build $sln.FullName --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore
          }
        }
        elseif ($csprojFiles.Count -gt 0) {
          foreach ($csproj in $csprojFiles) {
            Write-Host "Building project: $($csproj.Name)"
            dotnet build $csproj.FullName --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore
          }
        }
        else {
          Write-Host "No .NET projects found. Building sample app..."
          dotnet build SampleApp --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore
        }
        
    - name: Run Tests
      run: |
        Write-Host "Running tests..."
        
        $testProjects = Get-ChildItem -Path . -Recurse -Filter "*test*.csproj" -File
        $testCount = 0
        
        if ($testProjects.Count -gt 0) {
          foreach ($testProject in $testProjects) {
            Write-Host "Running tests in: $($testProject.Name)"
            dotnet test $testProject.FullName --configuration ${{ env.BUILD_CONFIGURATION }} --no-build --verbosity normal --logger "trx"
            $testCount++
          }
        }
        
        if ($testCount -eq 0) {
          Write-Host "No test projects found. Creating and running sample tests..."
          
          # Create a test project if none exists
          dotnet new xunit -n SampleTests --force
          cd SampleTests
          dotnet add reference ../SampleApp/SampleApp.csproj
          dotnet test --configuration ${{ env.BUILD_CONFIGURATION }} --logger "trx"
        }
        
        # Collect test results
        $testResults = Get-ChildItem -Path . -Recurse -Filter "*.trx"
        foreach ($result in $testResults) {
          Write-Host "Test results available at: $($result.FullName)"
        }
        
    - name: Code Analysis
      continue-on-error: true
      run: |
        Write-Host "Running code analysis..."
        
        # Security scan with built-in tools
        Write-Host "Scanning for secrets..."
        $secretsPatterns = @(
          'password\s*=\s*["'']?[^"'']*["'']?',
          'api[_-]?key\s*=\s*["'']?[^"'']*["'']?',
          'secret\s*=\s*["'']?[^"'']*["'']?',
          'connection[_-]?string\s*=\s*["'']?[^"'']*["'']?'
        )
        
        $potentialSecrets = @()
        foreach ($pattern in $secretsPatterns) {
          $matches = Select-String -Path . -Pattern $pattern -Recurse
          if ($matches) {
            $potentialSecrets += $matches
          }
        }
        
        if ($potentialSecrets.Count -gt 0) {
          Write-Warning "Potential secrets found: $($potentialSecrets.Count)"
          $potentialSecrets | Select-Object -First 5 | ForEach-Object {
            Write-Warning "  Line $($_.LineNumber) in $($_.Filename): $($_.Line)"
          }
        }
        else {
          Write-Host "No potential secrets found."
        }
        
    - name: Package Application
      run: |
        Write-Host "Packaging application..."
        
        $outputDir = "dist"
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
        
        $publishDir = "$outputDir/publish"
        
        # Publish the application
        $publishProjects = Get-ChildItem -Path . -Recurse -Filter "*.csproj" | Where-Object { $_.Name -notlike "*test*" } | Select-Object -First 1
        
        if ($publishProjects) {
          foreach ($project in $publishProjects) {
            Write-Host "Publishing: $($project.Name)"
            dotnet publish $project.FullName --configuration ${{ env.BUILD_CONFIGURATION }} --output $publishDir --no-build --self-contained false
          }
        }
        else {
          Write-Host "Publishing sample app..."
          dotnet publish SampleApp --configuration ${{ env.BUILD_CONFIGURATION }} --output $publishDir --no-build --self-contained false
        }
        
        # Create a deployment manifest
        $manifest = @{
          BuildId = "${{ github.run_id }}"
          BuildNumber = "${{ github.run_number }}"
          Commit = "${{ github.sha }}"
          Branch = "${{ github.ref_name }}"
          BuiltAt = Get-Date -Format "yyyy-MM-ddTHH:mm:ss"
          DotNetVersion = "${{ matrix.dotnet-version }}"
          WindowsServerVersion = "2022"
          GitHubWorkflow = "${{ github.workflow }}"
        }
        
        $manifest | ConvertTo-Json | Out-File "$outputDir/build-manifest.json"
        
        # Create a simple deployment script
        $deployScript = @'
@echo off
echo Deploying application...
echo Build ID: %BUILD_ID%
echo Commit: %COMMIT_SHA%
echo.
if exist "app" (
  echo Stopping existing application...
  timeout /t 3
)
echo Deploying new version...
xcopy /E /Y "publish\*" "app\"
echo Deployment completed!
'@
        
        $deployScript | Out-File "$outputDir/deploy.bat"
        
        Write-Host "Packaging completed. Output directory: $outputDir"
        Get-ChildItem $outputDir -Recurse | Format-Table Name, Length, LastWriteTime
        
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windows-build-${{ github.run_id }}-${{ matrix.dotnet-version }}
        path: |
          dist/
          **/*.trx
          **/bin/${{ env.BUILD_CONFIGURATION }}/
          **/TestResults/
        retention-days: 30
        if-no-files-found: error
        
    - name: Upload Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.run_id }}
        path: |
          **/TestResults/
          **/*.trx
        retention-days: 90
        
    - name: Cleanup Workspace
      if: always()
      run: |
        Write-Host "Cleaning up workspace..."
        
        # Remove temporary files
        Get-ChildItem -Path . -Recurse -Directory -Name obj, bin | ForEach-Object {
          Write-Host "Removing: $_"
          Remove-Item -Path $_ -Recurse -Force -ErrorAction SilentlyContinue
        }
        
        # Calculate workspace size
        $size = (Get-ChildItem -Path . -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB
        Write-Host "Final workspace size: $([math]::Round($size, 2)) MB"
        
    - name: Build Status
      if: always()
      run: |
        Write-Host "=========================================="
        Write-Host "BUILD SUMMARY"
        Write-Host "=========================================="
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Run ID: ${{ github.run_id }}"
        Write-Host "Run Number: ${{ github.run_number }}"
        Write-Host "Commit: ${{ github.sha }}"
        Write-Host "Triggered by: ${{ github.actor }}"
        Write-Host "DotNet Version: ${{ matrix.dotnet-version }}"
        Write-Host "Status: ${{ job.status }}"
        Write-Host "Windows Server: 2022"
        Write-Host "Runner: ${{ runner.name }}"
        Write-Host "=========================================="
        
  deploy:
    name: Deploy to Environment
    runs-on: windows-latest
    needs: build-and-test
    if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
    
    environment: 
      name: ${{ github.event.inputs.environment || 'staging' }}
      url: https://your-deployment-url.com
    
    steps:
    - name: Download Artifacts
      uses: actions/download-artifact@v4
      with:
        name: windows-build-${{ github.run_id }}-6.0.x
        path: artifacts
        
    - name: Display Deployment Info
      run: |
        Write-Host "=== DEPLOYMENT INFORMATION ==="
        Write-Host "Environment: ${{ github.event.inputs.environment || 'staging' }}"
        Write-Host "Deployment URL: ${{ vars.DEPLOYMENT_URL || 'Not configured' }}"
        Write-Host "Artifact Path: artifacts"
        
    - name: Simulate Deployment
      run: |
        Write-Host "Simulating deployment to ${{ github.event.inputs.environment || 'staging' }}..."
        
        # In a real scenario, you would deploy to:
        # - Azure App Service
        # - IIS
        # - Kubernetes
        # - VM
        # - etc.
        
        Write-Host "Deployment simulation completed!"
        Write-Host "Next steps would be:"
        Write-Host "1. Stop existing services"
        Write-Host "2. Backup current deployment"
        Write-Host "3. Deploy new artifacts"
        Write-Host "4. Start services"
        Write-Host "5. Run health checks"
        
    - name: Create Deployment Summary
      run: |
        $summary = @"
        # Deployment Summary
        
        ## Build Information
        - **Workflow**: ${{ github.workflow }}
        - **Run ID**: ${{ github.run_id }}
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        
        ## Deployment Details
        - **Environment**: ${{ github.event.inputs.environment || 'staging' }}
        - **Deployed At**: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
        - **Windows Server**: 2022
        - **.NET Version**: 6.0.x
        
        ## Artifacts
        - Build output: dist/publish/
        - Build manifest: dist/build-manifest.json
        - Deployment script: dist/deploy.bat
        
        ## Next Steps
        1. Verify deployment health
        2. Run smoke tests
        3. Update deployment documentation
        4. Notify stakeholders
        
        ---
        *Automatically generated by GitHub Actions*
        "@
        
        $summary | Out-File "deployment-summary.md"
        
    - name: Upload Deployment Summary
      uses: actions/upload-artifact@v4
      with:
        name: deployment-summary
        path: deployment-summary.md
